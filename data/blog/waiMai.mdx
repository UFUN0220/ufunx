---
title: 'WaiMai debug 2025'
date: '2025-07-23'
lastmod: '2026-01-01'
tags: ['debug','java']
summary: ''
images: []
authors: ['default']
---

## 苍穹外卖 6.12-6.23

**注意**：day4 和 day9 需自己手敲。

### day1-12 导入接口文档

**工具**：yapi

Apifox 创建项目后，在 `项目设置` -> `数据管理` -> `导入数据` 中选择 **yapi**，然后选择需要导入的文件。

不需要用 Postman。

### day2-4

新增员工接口发送重复数据，期望 500。若 401，重新调登录接口，生成新 token，设置全局参数。

信息提示常量类添加，后重新编译。源文件没有。

```java
public static final String ALREADY_EXISTS = "已存在";
```

代码中避免出现字符串，使用常量类更规范。

`SQLIntegrityConstraintViolationException` 若爆红，导 sql 包。

重新调试，若非预期输出，检查 `GlobalExceptionHandler` 第 40 行代码。

```java
String[] split = message.split(" ");
```

预期输出：响应码 200。

### day2-8

员工分页查询功能测试，若报 500，则查看 `EmployeeMapper.xml` 文件。

可能为生成的 sql 语句出错，注意分行，分号。

**IDEA 快捷键：**

* 选中一行：`Shift + Alt + 方向键`
* 选中一块：`Shift + Ctrl + 方向键`

### day3-3

公共字段自动填充

* `Signature.class` 中对接口 `Signature` 向下转型快捷键：`Ctrl + Alt + B`
* 查看子接口：`Ctrl + H`
* 若爆红，则导包。
* 删除选中的一行：`Ctrl + Y`

**IDEA 块注释：**

* **快捷键：** `Ctrl + Shift + /`
* **说明：** 添加块注释；再次使用，去掉块注释。
* **注意：** 如果已经写好代码块，使用块注释需要先选中要注释的块；去除注释的时候，不需要全部选中这块代码，只用光标在注释内容上按快捷键即可。

### day3-5

`category_id` 为逻辑外键。

*逻辑外键是数据库里没有设置，只是我们编程使用的时候逻辑上把它当作外键。*

### day3-6

新增菜品业务用到阿里云 OSS，免费试用 3 月。

* 参考资料：[Day11-04. 案例-文件上传-阿里云OSS-准备](https://www.bilibili.com/video/BV1m84y1w7Tb?spm_id_from=333.788.videopod.episodes&vd_source=876a200f005a9932dbcbfa1ce9fa6e5e&p=148)

### day3-11

菜品分页查询，`pageQuery` 的动态 sql 在 MySQL Workbench 中写。

```sql
select d.* , c.name from dish d left outer join category c on d.category_id=c.id
```

执行这句左外连接时，需选中左侧 `sky_take_out`。

### day4

从“根据分类 id 查询菜品”开始写。参考答案以及 day3 写的代码。

**易错点（SetmealController）：**

1. **3.2.1 批量删除套餐**：少写了 `@RequestParam` 导致删除接口测不通。
```java
delete(@RequestParam List<Long> ids){}
```

2. **4.2.1 根据 id 查询套餐**：`GetMapping` 里少写大括号导致修改套餐时看不到回显。
```java
@GetMapping("/{id}")
```

### day5-2

Redis 启动命令：

```bash
redis-server.exe redis.windows.conf
```

### day5-17

更新 docket 配置后，接口文档若直接刷新会报接口异常。关闭后重新打开网址。

### day6-3

单元测试若返回 500，启动 Redis 重新执行。

查询接口的实现类，选中单词，`Ctrl + Alt + B`。

### day6-8

微信开发者工具调试 `getUserProfile`，若点击第一个 button 后不弹“获取你的昵称，头像”框。

* **解决**：右上角点“详情-本地设置”修改调试基础库为 **2.27.0** 版本及以下（我选择的 2.26.2）。

### day6-12

小程序 IDE 优化空间不小。导入代码时，**勾选不使用云服务**。

*选了微信云服务后进去会白屏或者其他 bug，重新导入就好了。*

### day6-13

视频里用的 Postman，我用的 Apifox 的用户端接口，效果一样。传的四个参数，前两个自己保存过，后两个文档有说明。

### day6-18

调试刚开始，若 code 为 null，注意 `UserController` Login 方法中添加 `@RequestBody` 注解。

发现拦截器里校验令牌代码处的问题，输出当前员工/用户 id 语句后少了 `{}`。补上即可。

### day6-20

视频 7:27 左右出现的 `SetmealMapper` 文件中 70 行的 `getByIdWithDish` 函数，是我们定义过的 `getById`。

因为 Mapper 中我们直接使用了 `@Select()`，所以此处找不到小鸟从而进映射文件。从上面找个图标进映射文件 `SetmealMapper.xml` 粘贴就行。

**注意**：Day6-15 时若没配 yml（因为没下小程序 IDE），会导致小程序调试时登录后白屏，不显示任何信息。登录请求 200，但后端会报异常：登录失败。

### day7-11

调试时忘记启动类添加注解了，导致 Redis 中无 cache。

```java
@EnableCaching //开发缓存注解功能
```

**XML 爆红问题：**
发现 xml 里有些 `parameterType` 和 `resultType` 爆红。解决方案：忽略即可，不影响运行。

* 参考：[IDEA mapper下面的xml 关于parameterType爆红的原因](https://blog.csdn.net/CSDN_RLZ/article/details/109202469)
* 参考：[解决 mapper.xml 文件的 resultType 爆红问题](https://blog.csdn.net/qq_35132089/article/details/130236918)

### day8 (跳过微信支付)

跳过微信支付，订单支付内容可跳过（因个人身份无法配置）。

**代码调整（参考引文 1）：**

**1. 修改小程序代码**
修改 `pages/pay/index.js` 文件（约 245 行）：

```javascript
uni.redirectTo({url: '/pages/success/index?orderId=' + _this.orderId });
```

**2. 修改 `OrderServiceImpl` 下的 `payment` 方法**
生成空 JSON 替换原接口生成预支付交易单。

```java
public OrderPaymentVO payment(OrdersPaymentDTO ordersPaymentDTO) throws Exception {
    // 当前登录用户id
    Long userId = BaseContext.getCurrentId();
    User user = userMapper.getById(userId);

    //生成空JSON，跳过微信支付流程
    JSONObject jsonObject = new JSONObject();

    if (jsonObject.getString("code") != null && jsonObject.getString("code").equals("ORDERPAID")) {
        throw new OrderBusinessException("该订单已支付");
    }

    OrderPaymentVO vo = jsonObject.toJavaObject(OrderPaymentVO.class);
    vo.setPackageStr(jsonObject.getString("package"));
    return vo;
}
```

**3. 修改 `OrderController**`
调用 `orderService.paySuccess` 方法，传入订单号，直接更新数据库订单状态。

```java
@PutMapping("/payment")
@ApiOperation("订单支付")
public Result<OrderPaymentVO> payment(@RequestBody OrdersPaymentDTO ordersPaymentDTO) throws Exception {
    log.info("订单支付：{}", ordersPaymentDTO);
    OrderPaymentVO orderPaymentVO = orderService.payment(ordersPaymentDTO);
    log.info("生成预支付交易单：{}", orderPaymentVO);
    // 模拟支付成功，更新数据库订单状态 -此时没有回调
    orderService.paySuccess(ordersPaymentDTO.getOrderNumber());
    return Result.success(orderPaymentVO);
}
```

### day9

**取消订单**

**注释掉微信支付退款接口即可。**

**用户端取消订单逻辑修改（`OrderServiceImpl` 中）：**
订单处于待接单状态下取消，需要进行退款。由于前面模拟微信支付，实际上并未支付，此时用户端取消订单，需要跳过微信支付退款接口，直接修改数据库订单状态。

```java
/**
 * 用户取消订单
 * @param id
 */
public void userCancelById(Long id) throws Exception {
    // 根据id查询订单
    Orders ordersDB = orderMapper.getById(id);

    // 校验订单是否存在
    if (ordersDB == null) {
        throw new OrderBusinessException(MessageConstant.ORDER_NOT_FOUND);
    }

    //订单状态 1待付款 2待接单 3已接单 4派送中 5已完成 6已取消
    if (ordersDB.getStatus() > 2) {
        throw new OrderBusinessException(MessageConstant.ORDER_STATUS_ERROR);
    }

    Orders orders = new Orders();
    orders.setId(ordersDB.getId());

    // 订单处于待接单状态下取消，需要进行退款
    if (ordersDB.getStatus().equals(Orders.TO_BE_CONFIRMED)) {
        // 跳过调用微信支付退款接口逻辑
        // 支付状态修改为 退款
        orders.setPayStatus(Orders.REFUND);
    }

    // 更新订单状态、取消原因、取消时间
    orders.setStatus(Orders.CANCELLED);
    orders.setCancelReason("用户取消");
    orders.setCancelTime(LocalDateTime.now());
    orderMapper.update(orders);
}
```

### day10-5

生成 Cron 表达式，推荐直接使用 AI 生成。

### day10-12

关于 day10 的部分需要修改。使用 `getByNumber` 方法查询订单。

**跳过配置：**
直接跳过内网穿透工具配置和微信支付回调的相关配置：在 yml 文件中仅配置 appid 和 secret 即可，其余均可注释掉。

**修改 `OrderServiceImpl` 中的 `paySuccess` 代码：**

```java
public void paySuccess(String outTradeNo) {
    // 根据订单号查询订单
    Orders ordersDB = orderMapper.getByNumber(outTradeNo);

    // 根据订单id更新订单的状态、支付方式、支付状态、结账时间
    Orders orders = Orders.builder()
            .id(ordersDB.getId())
            .status(Orders.TO_BE_CONFIRMED)
            .payStatus(Orders.PAID)
            .checkoutTime(LocalDateTime.now())
            .build();
    orderMapper.update(orders);

    //通过WebSocket实现来单提醒  type orderId content
    Map map = new HashMap<>();
    map.put("type", 1);//消息类型，1表示来单提醒 2表示客户催单
    map.put("orderID", ordersDB.getId());//订单id
    map.put("content", "订单号：" + outTradeNo);
    
    //通过websocket向客户端浏览器推送消息
    String json = JSON.toJSONString(map);
    webSocketServer.sendToAllClient(json);
}
```

**测试注意：**

* 若第一次确认支付后无语音播报，则重新登录前端页面（建议用 Edge 默认设置）。
* 若语音播报一直响，则注释掉定时任务每五秒发送消息给客户端的代码。
* 若 Message 为空，则小程序 IDE 重新编译。

### day11

存放营业额时 `put` 方法里写成 `("beginTime", beginTime)` 了（自动填充导致），会导致图表中所有日期均为同一数据。

```java
Map map=new HashMap();
map.put("begin",beginTime);
map.put("end",endTime);
```

### day11-21

若销量排名统计测试时，Top10 只有“昨日”有数据，则检查 `ReportServiceImpl` 文件中，`getSalesTop10Statistics` 方法中。

**错误点：** 第一个参数误写为 `begin`（视频或自动补全错误）。

**修正：**

```java
LocalDateTime endTime = LocalDateTime.of(end, LocalTime.MAX);
```
